#pragma once
#include <string>
#include <cstdint>
#include <vector>
#include <optional>
#include <memory>
#include <unordered_map>
#include <mutex>
#include <chrono>

enum class Side : uint8_t {
    BUY = 0,
    SELL = 1
};

enum class OrderType : uint8_t {
    MARKET = 0,
    LIMIT = 1
};

enum class OrderStatus : uint8_t {
    NEW = 0,
    FILLED = 1,
    PARTIALLY_FILLED = 2,
    CANCELED = 3,
    REJECTED = 4
};

struct Order {
    std::string id;          // unique order ID (generated by system)
    std::string symbol;      // e.g., "BTC-USD"
    Side side;               // BUY or SELL
    OrderType type;          // MARKET or LIMIT
    double price{0};         // required for LIMIT, ignored for MARKET
    double qty{0};           // quantity to buy/sell
    OrderStatus status{OrderStatus::NEW};
    std::int64_t ts_ns{0};   // timestamp when order was created
    std::string user_id;     // optional: user identifier
};

// Simple memory-based order store (thread-safe)
class IOrderStore {
public:
    virtual ~IOrderStore() = default;
    virtual std::string add(const Order& order) = 0;
    virtual std::optional<Order> get(const std::string& id) const = 0;
    virtual std::vector<Order> list() const = 0;
    virtual bool cancel(const std::string& id) = 0;
    virtual bool update_status(const std::string& id, OrderStatus status) = 0;
};

class MemoryOrderStore : public IOrderStore {
public:
    std::string add(const Order& order) override {
        std::lock_guard<std::mutex> lk(mutex_);
        
        Order o = order;
        // Generate ID if not provided
        if (o.id.empty()) {
            o.id = generate_id();
        }
        
        // Set timestamp if not provided
        if (o.ts_ns == 0) {
            o.ts_ns = now_ns();
        }
        
        // Default status to NEW
        if (o.status == OrderStatus::NEW) {
            o.status = OrderStatus::NEW;
        }
        
        orders_[o.id] = o;
        return o.id;
    }
    
    std::optional<Order> get(const std::string& id) const override {
        std::lock_guard<std::mutex> lk(mutex_);
        auto it = orders_.find(id);
        if (it != orders_.end()) {
            return it->second;
        }
        return std::nullopt;
    }
    
    std::vector<Order> list() const override {
        std::lock_guard<std::mutex> lk(mutex_);
        std::vector<Order> result;
        result.reserve(orders_.size());
        for (const auto& [id, order] : orders_) {
            result.push_back(order);
        }
        return result;
    }
    
    bool cancel(const std::string& id) override {
        std::lock_guard<std::mutex> lk(mutex_);
        auto it = orders_.find(id);
        if (it != orders_.end() && 
            (it->second.status == OrderStatus::NEW || 
             it->second.status == OrderStatus::PARTIALLY_FILLED)) {
            it->second.status = OrderStatus::CANCELED;
            return true;
        }
        return false;
    }
    
    bool update_status(const std::string& id, OrderStatus status) override {
        std::lock_guard<std::mutex> lk(mutex_);
        auto it = orders_.find(id);
        if (it != orders_.end()) {
            it->second.status = status;
            return true;
        }
        return false;
    }

private:
    static std::int64_t now_ns() {
        using namespace std::chrono;
        return duration_cast<nanoseconds>(
            steady_clock::now().time_since_epoch()
        ).count();
    }
    
    std::string generate_id() {
        // Simple ID generation: timestamp + counter
        static std::uint64_t counter = 0;
        return "ORD-" + std::to_string(now_ns()) + "-" + std::to_string(++counter);
    }
    
    mutable std::mutex mutex_;
    std::unordered_map<std::string, Order> orders_;
};

inline std::unique_ptr<IOrderStore> make_memory_store() {
    return std::make_unique<MemoryOrderStore>();
}

// Helper functions for string conversion (for JSON/display)
inline const char* to_cstr(Side side) {
    return side == Side::BUY ? "BUY" : "SELL";
}

inline const char* to_cstr(OrderType type) {
    return type == OrderType::MARKET ? "MARKET" : "LIMIT";
}

inline const char* to_cstr(OrderStatus status) {
    switch (status) {
        case OrderStatus::NEW: return "NEW";
        case OrderStatus::FILLED: return "FILLED";
        case OrderStatus::PARTIALLY_FILLED: return "PARTIALLY_FILLED";
        case OrderStatus::CANCELED: return "CANCELED";
        case OrderStatus::REJECTED: return "REJECTED";
        default: return "UNKNOWN";
    }
}

inline Side parse_side(const std::string& s) {
    if (s == "BUY" || s == "buy") return Side::BUY;
    return Side::SELL;
}

inline OrderType parse_order_type(const std::string& s) {
    if (s == "MARKET" || s == "market") return OrderType::MARKET;
    return OrderType::LIMIT;
}
